use std::str::FromStr;
use agl_rs::agl::*;
use std::collections::HashMap;

grammar(symbols: &mut HashMap<String, i32>, output: &mut Vec<GSInstruction>);

pub Program: Vec<GSInstruction> = {
    <Statement*> => <>.into_iter().flatten().collect::<Vec<_>>(),
}

Statement: Vec<GSInstruction> = {
    Block,
    <i:Ident> "=" <e:Expr> ";" => { 
        symbols.insert(i.clone(), e);
        vec![]
    },
    "if" <b:BitWidth> "(" <addr:Expr> <op:LogicalOp> <e:Expr> ")" <s:Statement> => {
        let mut if_instruction = GSInstruction::Conditional(b, op, addr, e);

        //for each s in statement, place if_block before it
        let mut out = vec![];
        for i in s {
            out.push(if_instruction.clone());
            out.push(i);
        }
        out
    },
    <GSInstruction> => vec![<>],
}

Block: Vec<GSInstruction> = {
    "{" <Statement*> "}" => <>.into_iter().flatten().collect::<Vec<_>>(),
}

GSInstruction: GSInstruction = {
    "write" <b:BitWidth> <addr:Expr> <e:Expr> ";" => GSInstruction::Write(b, addr, e),
}

Expr: i32 = {
    Term,
};

Term: i32 = {
    <l:Term> "+" <r:Factor> => l + r,
    <l:Term> "-" <r:Factor> => l - r,
    Factor,
};

Factor: i32 = {
    <l:Factor> "*" <r:Primary> => l * r,
    <l:Factor> "/" <r:Primary> => l / r,
    Primary,
};

Primary: i32 = {
    Num,
    Hex,
    <i:Ident> => {
        // lookup the value of the identifier in the symbol table
        symbols.get(&i).unwrap().clone()
    },
    "(" <Expr> ")",
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

Hex: i32 = {
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(<>.trim_start_matches("0x"), 16).unwrap(),
};

Ident: String = {
    //ident starts with an alpha, followed by any number of alphanum and underscore
    <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => String::from_str(s).unwrap()
}

LogicalOp: LogicalOp = {
    "==" => LogicalOp::Equal,
    "!=" => LogicalOp::NotEqual,
    "<" => LogicalOp::LessThan,
    ">" => LogicalOp::GreaterThan,
}

BitWidth: BitWidth = {
    "8" => BitWidth::Bit8,
    "16" => BitWidth::Bit16,
    "32" => BitWidth::Bit32,
}

// pub Hex: () = {
//     r"0[xX][0-9a-fA-F]+" => ()
// };
// Float: f64 = {
//     <n:r"[0-9]+(\.[0-9]+)?"> => f64::from_str(n).unwrap()
// }