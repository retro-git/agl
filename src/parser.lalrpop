use std::str::FromStr;
use agl_rs::ast::*;

grammar;

pub Program: Vec<Declaration> = {
    <Declaration*> => <>
}

Declaration: Declaration = {
    <Ident> "=" <Expr> ";" => Declaration::Assign(<>),
    "write8" <Expr> <Expr> ";" => Declaration::Statement(Statement::Write8(<>)), 
}

// Assign: (String, Box<Expr>) = {
//     <Ident> "=" <Expr> => (name, expr)
// }

// Expr: Expr = {
//     Int => Expr::Int(<>),
//     Ident => Expr::Ident(<>),
// }

Expr: i32 = {
    <l:Expr> "+" <r:Factor> => l + r,
    <l:Expr> "-" <r:Factor> => l - r,
    Factor,
};

Factor: i32 = {
    <l:Factor> "*" <r:Term> => l * r,
    <l:Factor> "/" <r:Term> => l / r,
    Term,
};

Term: i32 = {
    Num,
    "(" <Expr> ")",
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

Ident: String = {
    //ident starts with an alpha, followed by any number of alphanum and underscore
    <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => String::from_str(s).unwrap()
}

Int: i32 = {
    <n:r"[0-9]+"> => i32::from_str(n).unwrap()
}

// Number: f64 = {
//     <n:r"[0-9]+(\.[0-9]+)?"> => f64::from_str(n).unwrap()
// }

// Expr: Expr = {
//     <e:Term> "+" <e2:Expr> => Expr::Add(Box::new(e), Box::new(e2)),
//     <e:Term> "-" <e2:Expr> => Expr::Sub(Box::new(e), Box::new(e2)),
//     <e:Term> => e
// }

// Term: Expr = {
//     <e:Factor> "*" <e2:Term> => Expr::Mul(Box::new(e), Box::new(e2)),
//     <e:Factor> "/" <e2:Term> => Expr::Div(Box::new(e), Box::new(e2)),
//     <e:Factor> => e
// }

// Factor: Expr = {
//     <e:Primary> "^" <e2:Factor> => Expr::Pow(Box::new(e), Box::new(e2)),
//     <e:Primary> => e
// }

// Primary: Expr = {
//     <n:Number> => Expr::Number(n),
//     <i:Ident> => Expr::Ident(i),
//     "(" <e:Expr> ")" => e
// }

// Number: f64 = {
//     <n:r"[0-9]+(\.[0-9]+)?"> => f64::from_str(n).unwrap()
// }

